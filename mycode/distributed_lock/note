锁
    1.互斥锁
    2.自旋锁
    3.原子变量
    4.读写锁
    5.条件变量
    6.信号量
        sem_init (&sem, pshared, value)
        sem_wait p操作
        sem_post v操作

IPC
    1.pipe
    2.FIFO
    3.信号量
    4.消息队列
    5.共享内存
    6.socket
    7.信号

分布式锁
    用户实现
        基于中间件来实现
        资源存储在中间件
        加锁解锁行为属于中间件的也行来实现
    互斥类型的锁

    锁 = 资源 + 行为(加锁，解锁)

1.数据库
2.zk, etcd

请求回应的模式
网络通信的方式

加锁：原来没有标记，现在打上标记
解锁：持锁方去除标记(谁加的锁，谁释放锁)

//消费者线程
pthread_mutex_lock(&mutex);
while (condition) {
    pthread_cond_wait(&cond, &mutex);
}
...
pthread_mutex_unlock(mutex);

生产者线程
pthread_mutex_lock(&mutex);
...修改条件
pthread_mutex_unlock(&mutex);
pthread_cond_signal(&cond);

虚假唤醒
1.被信号打算
2.多线程环境下，信号劫持，signal唤醒至少一个线程，可能是多个
