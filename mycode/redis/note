
redis 远程字典服务
    通过tcp与redis简历链接交互
    请求回应模式
    通过字典的方式索引存储数据

内存数据库
    数据都在内存中，不可能出现，需要的数据不在内存当中，而在磁盘中

kv数据库
    存储方式
    操作方式

数据结构数据库
    所有的key都是字节串
    value的类型
        string 字节串(字符串为\0为分割符，字节串以长度信息描述) 长度小于1mb加倍扩容，超过1mb每次只多扩容1mb，字符串的最大长度为512mb
        list    插入有序
        hash
        zset 有序集合(元素唯一)
        set 集合
        stream 消息队列
        hyperloglog
        
    command:
        keys *  //遍历所有key

        string
            set teacher qiao
            get teacher
            set teacher 1000
            object encoding teacher //查看存储类型
            incr teacher //int类型，原子自增+1，并把最新的值返回
            incr counter //不存在counter，创建并自增
            incrby counter 100  //自增100
            decr counter        //counter--
            decrby counter 50   //counter -= 50
            setnx counter 10000 //key不存在才能设置成功，返回0设置失败，返回1成功
            del counter         //删除counter 
            setbit bitstr 1 1   // 第一位置1
            setbit bitstr 2 1   // 第二位置1
            getbit bitstr 3     // return 0, 第三位没有置1
            bitcount bitstr 0 -1// return 2
        list
            lpush/rpush teachers qiao guo wei
            lpop/rpop key
            blpop/brpop teachers 0 //没有元素时阻塞等待
            lrange teachers 0 -1
            ltrim teacher 0 4       //保留左边的5个数据
        hash
            hset teacher:10001 name mark
            hgetall teacher:10001
            hmset key value1 
            HINCRBY counter:1000 sign 1 //加
            HLEN teacher:10001          //查看hash里面有多少元素
        set
            sadd teacher:set qiao guo wei
            smemebers teacher:set
            scard key                   //计算集合元素个数
            sismember teacher:set qiao  //qiao是否是存储集合teacher:set的成员
            srandmember teacher:set [count]    //随机返回teacher:set集合中的一个或者多个元素，不删除这些元素
            spop teacher:set [count]    //移除并返回一个或多个元素
            sdiff key [key ...]     //差集
            sinter key [key ...]    //交集
            sunion key [key ...]    //并集
        zset
            zadd teacher:rank 98 mark 99 darren 100 king
            zrange teacher:rank 0 -1 withscores


redis存储结构(kv)
    存储key的数组，大小为2的n次方
    key经过hash函数(siphash)计算，生成64位整数，对数据长度取余，得到数组索引值

-- redis lua脚本
local record = KEYS[1]
redis.call("LPUSH", "says", record)
redis.call("LTRIM", "says", 0, 4)

redis pipeline
    通过一次发送多次请求命令，从而减少网络传输的时间
    各条指令之间是无关的

某个用户 某个行为 事件范围 发生N次

expire key 10 设置过期时间

s服务器需要和redis建立多少条连接？
    1.基本操作，只需要一条连接
    2.阻塞连接的需求，另外建立一条连接
    3.需要监听发布模式，另外建立一条连接
        PSUBSCRIBE *.news  /SUBSCRIBE messagebox   订阅频道
        PUBLISH messagebox "hello qiao" 发布消息
        redis停机重启，pub/sub的消息是不会持久化的，所有的消息被直接丢弃(不确保消息到达)


redis事务
    cpu缓存一致，锁总线，原子性，原子变量，原子操作
    比如i++指令(三个指令)，在一个核心里面运行，其他核心只能看到这个指令完成，或这个指令还没有开始

    单个命令操作，具备原子性，因为redis是单线程的

    ACID
    原子性
    一致性
        完整约束的一致
            key对应的是什么类型的，只能用对应类型的指令操作他
        用户的逻辑一致
    隔离性：
        各个事务之间互相影响的程度，redis是单线程，天然具备隔离性
    持久性：

    multi           //开启事务，命令入队列
    exec            //提交事务，
    discard         //取消事务，清空队列
    watch

lua脚本
    多条指令作为一个事务执行
    把lua脚本发送给redis，返回hash值，redis存储lua脚本
    eval 'local key = KEYS[1]; local val = redis.call("get", key); \
        if not val then val = 1 end; redis.call("set", key, val*2); return val*2;' 1 score:1
        
    script load 'local key = KEYS[1]; local val = redis.call("get", key); \
        if not val then val = 1 end; redis.call("set", key, val*2); return val*2;'
    "a614235c331e0c17994b40045ea88f1cb1e78895"
    EVALSHA a614235c331e0c17994b40045ea88f1cb1e78895 1 score:1

异步连接/同步连接
    技术拆解
    1.与redis建立连接，connect(fd, &addr, &len); 非阻塞io
        a.创建socket, 设置fd为非阻塞
        b.connect -1, errno = EINPROGRESS
        c.fd注册到epoll 写事件
        d.如果连接建立成功，fd的写事件进行响应，注销写事件
    2.向redis发送数据 a.使用redis协议加密 b.通过tcp发送过去
        a.int n = write(fd, buf, sz); if n < sz && n != -1; n = -1, errno = EWOULDBLOCK 说明发送缓冲区已满
        b.注册写事件, 如果写事件触发，write(fd, buf, sz); 如果发送完毕， 注销写事件
        c.注册读事件
    3.读取redis的返回 a.通过tcp接受数据，分割数据包 b.使用redis协议解密
        a.读事件触发，int n = read(fd, buf, sz)
        b.根据redis协议，分割数据包

    将hiredis融入到自己的代码中
    ac->ev.addRead = redisLibeventAddRead;              //注册读事件
    ac->ev.delRead = redisLibeventDelRead;              //注销读事件
    ac->ev.addWrite = redisLibeventAddWrite;            //注册写事件
    ac->ev.delWrite = redisLibeventDelWrite;            //注销写事件
    ac->ev.cleanup = redisLibeventCleanup;
    ac->ev.scheduleTimer = redisLibeventSetTimeout;
    ac->ev.data = e;

Redis主从同步与对象模型

高可用
    合理的时间给出一个合理的回复

    主从复制(数据备份)
        异步复制
            可能带来数据不一致
        环形缓冲区，复制偏移量
            replica持有复制偏移量
                如果复制偏移量在mater环形缓冲区中，master将对应的数据推送给replica，增量更新
                复制偏移量不在环形缓冲区，需要全量更新
            replica的复制偏移量越大，数据越新
        runid 标识主从映射关系
            知道master的id，执行relicaof masterid，配置中达成一致

    哨兵模式
        哨兵集群
            监控 主节点是不是宕机了，监控那个从数据库数据新一些
        
    cluster
        去中心化

        创建文件夹
            mkdir -p 7001 7002 7003 7004 7005 7006
        编辑7001.conf
            pidfile "/root/redis-cluster/7001/7001.pid"
            logfile "/root/redis-cluster/7001/7001.log"
            dir /root/redis-cluster/7001/
            port 7001
            daemonize yes
            cluster-enabled yes
            cluster-config-file nodes-7001.conf
            cluster-node-timeout 15000

