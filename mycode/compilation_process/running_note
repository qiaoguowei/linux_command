note: 可执行文件不会自己运行，必须由操作系统“启动”----本质是操作系统为程序分配资源，把机器码加载到内存中，让CPU执行。

以linux x86_64为例，程序运行阶段分5个步骤
步骤1：程序启动
    1.解析可执行文件的元信息（如ELF头），验证文件合法性（是否是当前平台的可执行文件，是否有执行权限）
    2.为程序创建一个独立的进程（进程是程序运行的实例，是操作系统资源分配的基本单位）
    3.为进程分配进程控制块（PCB），记录进程的PID、状态、内存布局、寄存器信息等

步骤2：内存加载（由操作系统的加载器完成）
    操作系统的程序加载器（Loader）把可执行文件的内容加载到进程的虚拟地址空间（x86_64用户态是低128TB虚拟地址，48位有效），核心是构建进程的虚拟内存布局
    （从高地址到低地址）
    高地址 ->   栈区（stack）：存放局部变量、函数参数、返回地址、自动分配释放
                堆区（Heap）：动态内存分配（new/malloc），手动分配释放（delete/free）
                数据段（Data/BSS）：存放全局变量、静态变量（.data已经初始化，.bss未初始化）
                代码段（Text）：存放程序的机器码，只读（防止程序篡改自身指令）
    低地址 ->   程序入口、库代码段

步骤3：初始化（程序运行前的准备）
    加载完成后，操作系统对程序进行初始化，执行main 函数之前的代码
    1.全局 / 静态变量初始化：对数据段中的全局变量、静态变量完成最终初始化（如g_val=10、s_val=5，预处理 / 编译阶段只是赋值，运行时才真正写入内存）；
    2.全局对象构造：如果有自定义的全局类对象，执行其构造函数（C++ 特有的，C 语言没有）；
    3.初始化 C++ 标准库：如初始化cout的输出流、堆内存分配器等；
    4.设置程序入口：操作系统把 CPU 的程序计数器（PC） 设置为程序的真正入口地址（不是 main，而是编译器插入的启动函数，如 Linux 下的_start，该函数会最终调用main）。

步骤 4：执行主程序（CPU 逐条执行机器码）
    这是程序的核心运行阶段，由 CPU 主导，按「取指→译码→执行」的指令周期逐条执行内存中的机器码：
    1.CPU 从程序计数器（PC） 指向的地址取一条机器码指令；
    2.译码器把机器码翻译成 CPU 能识别的操作（如赋值、加法、函数调用、IO 输出）；
    3.执行指令（如把g_val + s_val的结果 15 赋值给局部变量l_val，调用cout的机器码完成控制台打印）；
    4.程序计数器（PC）自动指向下一条指令，重复上述过程，直到执行到main函数的return 0。

步骤 5：程序退出（资源释放）
    当程序执行到main的return，或调用exit(0)/_exit(0)时，程序进入退出阶段，操作系统会做资源回收（避免内存泄漏、资源占用）：当程序执行到main的return，或调用exit(0)/_exit(0)时，程序进入退出阶段，操作系统会做资源回收（避免内存泄漏、资源占用）：
    1.执行main 函数之后的代码：如全局类对象的析构函数（C++ 特有的）、关闭标准输入输出流；
    2.释放进程占用的资源：包括虚拟内存、文件句柄、网络套接字、CPU 时间片等；
    3.销毁进程控制块（PCB），把进程的退出码（如return 0的 0）返回给父进程（如终端）；




